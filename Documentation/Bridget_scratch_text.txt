What does "stateless" mean here: "These can be called independently and are stateless, as utility methods should be"?

_______________


integrate these responses: 
Integration Checklist: Where and How to Apply Each Improvement

1. Advance ETA on Every Edge (Path Traversal Logic)
• Where: In your path traversal/scoring loop (e.g., in TrainPrepService or your prototype).
• How: Always increment currentTime after every edge, not just bridges.
• Why: Ensures accurate predicted arrival times for every segment.
for edge in path.edges {
    // Advance ETA for every edge
    currentTime = currentTime.addingTimeInterval(edge.travelSeconds)
    if edge.isBridge {
        // ...predictor logic...
    }
}

(Define travelSeconds as the canonical field for all duration math.)

⸻

2. Probability Aggregation—Use Union, Not Sum
• Where: In your network-level probability calculation (when combining path probabilities).
• How: Instead of summing, use the formula:
let anyPathOK = 1.0 - pathProbabilities.map { 1.0 - $0 }.reduce(1.0, *)

• Why: Correctly models the chance that at least one path is successful.

⸻

3. Log-Domain Aggregation and Probability Clamping
• Where: When multiplying many probabilities (to avoid underflow).
• How:
let epsLow = 0.05, epsHigh = 0.99
  let logP = bridgeProbs.map { min(max($0, epsLow), epsHigh) }.map(log).reduce(0, +)
  let pathProb = exp(logP)

• Why: Improves numerical stability, especially for long paths.

⸻

4. Canonical Time Units
• Where: All edge definitions and ETA math.
• How: Define all travel durations as TimeInterval (seconds), not minutes.
• Why: Prevents accidental errors and makes API use consistent.

⸻

5. Strong Typing for Graph Primitives
• Where: In your graph module (Node, Edge) and adjacency list construction.
• How: Use dedicated NodeID: Hashable types; build adjacency list in init for reliability.
• Why: Avoids bugs from accidental key duplication and keeps graph structure robust.

⸻

6. Explicitly Model Bidirectionality
• Where: When creating your graph.
• How: For each two-way road, insert two directed edges; never assume roads are symmetric.
• Why: Matches real-world traffic logic and avoids routing bugs.

⸻

7. Seeded Randomness in Mocks
• Where: In your synthetic probability/mock predictor.
• How: Pass a seeded PRNG as an argument or property.
• Why: Ensures deterministic, repeatable tests.

⸻

8. Batch Prediction API
• Where: In your bridge predictor interface.
• How: Collect all (bridgeId, eta, features) triples and use a predictBatch method (even if mocked).
• Why: Matches how you’ll call Core ML for performance later.

⸻

9. ETA Windows (Optional)
• Where: In your ETA estimation function.
• How: Return (mean, min, max), even if you use only mean for now.
• Why: Future-proofs your code for modeling travel time uncertainty.

⸻

10. Acceptance Checks & Known Limitations
• Where: In your test suite and scoring logic.
• How: Assert results are in [0,1], and mark shared-bridge path dependencies as open issues.
• Why: Ensures logic is robust and edge cases are documented.

⸻

11. Tiny Code Nits
• Where: Throughout your code files.
• How:
   • Import CoreLocation conditionally.
   • Rename ambiguous variables (e.g., Graph.edges → allEdges).
   • Validate paths for contiguity.
• Why: Improves clarity and correctness.

⸻

12. Expanded Test Plan
• Where: In your test suite (TrainPrepServiceTests or similar).
• How: Add property-based, underflow, and no-safe-route tests as described.
• Why: Catches subtle bugs and guards against regressions.

⸻

How to Sequence These Fixes

1. Refactor graph, edge, and path types for time/identity.
2. Update path traversal and probability scoring logic per #1-4.
3. Implement seeded randomness and batch APIs in mocks.
4. Add and run property/edge-case tests.
5. Document known limitations and future work (shared-bridge dependencies, etc.).

⸻

Final Advice

• Apply these changes in small, test-backed commits.
• Keep mocks and injectability in your architecture to support fast iteration and future model swaps.
• Document every new assumption, type, and calculation for team clarity.
• Test rigorously: edge-cases, deep paths, and no-safe-route scenarios.
